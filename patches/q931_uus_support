Description: Added Q931 UUS support
Author: vir@ctm.ru
---
Index: yate/libs/ysig/q931.cpp
===================================================================
--- yate.orig/libs/ysig/q931.cpp	2016-01-15 12:40:57.000000000 +0300
+++ yate/libs/ysig/q931.cpp	2016-01-15 12:47:29.000000000 +0300
@@ -116,6 +116,10 @@
 	    if (!addParam(dest,data))
 		dest->addParam(name,String((unsigned int)(data & mask)));
 	}
+    inline void addNumericParam(NamedList* dest, u_int8_t data) const {
+	    String s((unsigned int)data);
+	    dumpDataBit7(dest, (const uint8_t*)s.c_str(), s.length(), false);
+	}
 
     inline void dumpData(NamedList* dest, const u_int8_t* data, u_int32_t len) const
 	{ SignallingUtils::dumpData(0,*dest,name,data,len); }
@@ -556,6 +560,23 @@
     return !m_keypad.null();
 }
 
+bool ISDNQ931IEData::processUserUser(ISDNQ931Message* msg, bool add,
+	ISDNQ931ParserData* data)
+{
+    if (!msg)
+	return false;
+    if (add) {
+	ISDNQ931IE* ie = new ISDNQ931IE(ISDNQ931IE::UserUser);
+	ie->addParam("protocol", m_uuprotocol);
+	ie->addParam("information",m_uuinformation);
+	msg->appendSafe(ie);
+	return true;
+    }
+    m_uuprotocol = msg->getIEValue(ISDNQ931IE::UserUser,"protocol");
+    m_uuinformation = msg->getIEValue(ISDNQ931IE::UserUser,"information");
+    return !m_uuinformation.null();
+}
+
 /**
  * ISDNQ931State
  */
@@ -1292,6 +1313,8 @@
     m_data.processCallingNo(msg,false);
     // *** Display
     m_data.processDisplay(msg,false);
+    // *** UUS
+    m_data.processUserUser(msg,false);
     // Set message parameters
     msg->params().setParam("caller",m_data.m_callerNo);
     msg->params().setParam("called",m_data.m_calledNo);
@@ -1303,6 +1326,10 @@
     msg->params().setParam("callerscreening",m_data.m_callerScreening);
     msg->params().setParam("callednumtype",m_data.m_calledType);
     msg->params().setParam("callednumplan",m_data.m_calledPlan);
+    if(m_data.m_uuinformation) {
+	msg->params().setParam("uuprotocol",m_data.m_uuprotocol);
+	msg->params().setParam("uuinformation",m_data.m_uuinformation);
+    }
     if(q931()->m_overlapEnabled)
 	msg->params().setParam("overlapped",String::boolText(m_overlap));
     return new SignallingEvent(SignallingEvent::NewCall,msg,this);
@@ -1724,6 +1751,12 @@
 	m_data.m_calledNo = sigMsg->params().getValue(YSTRING("called"));
 	if(!(m_overlap && !m_data.m_calledNo))
 	    m_data.processCalledNo(msg,true);
+	// User to User
+	if(sigMsg->params().getValue(YSTRING("uuinformation"))) {
+	    m_data.m_uuprotocol = sigMsg->params().getValue(YSTRING("uuprotocol"));
+	    m_data.m_uuinformation = sigMsg->params().getValue(YSTRING("uuinformation"));
+	    m_data.processUserUser(msg,true);
+	}
 	// Send
 	changeState(CallInitiated);
 	if (m_net && !q931()->primaryRate()) {
@@ -5687,7 +5720,7 @@
     if (!len)
 	return errorParseIE(ie,s_errorNoData,0,0);
     // data[0]: Protocol discriminator
-    s_ie_ieUserUser[0].addIntParam(ie,data[0]);
+    s_ie_ieUserUser[0].addNumericParam(ie, data[0]);
     if (len == 1)
 	return errorParseIE(ie,s_errorWrongData,0,0);
     // Remaining data: user information
@@ -6099,11 +6132,16 @@
 
 bool Q931Parser::encodeUserUser(ISDNQ931IE* ie, DataBlock& buffer)
 {
-    // TODO: implement it!
-    u_int8_t tmp[10];
-    tmp[0]=0x7e;tmp[1]=0x08;tmp[2]=0x04;tmp[3]=0x30;tmp[4]=0x39;
-    tmp[5]=0x32;tmp[6]=0x21;tmp[7]=0x30;tmp[8]=0x39;tmp[9]=0x32;
-    buffer.assign(tmp,sizeof(tmp));
+    DataBlock data;
+    String hex = ie->getValue(s_ie_ieUserUser[1].name);
+    data.unHexify(hex.c_str(), hex.length(), ' ');
+
+    u_int8_t head[3] = {(u_int8_t)ie->type()};
+    head[1] = (u_int8_t)data.length() + 1; // protocol discriminator byte plus data
+    head[2] = (u_int8_t)ie->getIntValue(s_ie_ieUserUser[0].name);
+
+    buffer.assign(head, sizeof(head));
+    buffer.append(data);
     return true;
 }
 
Index: yate/libs/ysig/yatesig.h
===================================================================
--- yate.orig/libs/ysig/yatesig.h	2016-01-15 12:40:57.000000000 +0300
+++ yate/libs/ysig/yatesig.h	2016-01-15 12:44:09.000000000 +0300
@@ -13894,6 +13894,7 @@
     bool processNotification(ISDNQ931Message* msg, bool add, ISDNQ931ParserData* data = 0);
     bool processCalledNo(ISDNQ931Message* msg, bool add, ISDNQ931ParserData* data = 0);
     bool processCallingNo(ISDNQ931Message* msg, bool add, ISDNQ931ParserData* data = 0);
+    bool processUserUser(ISDNQ931Message* msg, bool add, ISDNQ931ParserData* data = 0);
 
     // IE parameters
     String m_display;                    // Display: The data
@@ -13920,6 +13921,8 @@
     String m_channelSelect;              // ChannelID: Channel select
     String m_channels;                   // ChannelID: Channel list or slot map
     String m_restart;                    // Restart: The class of restarting circuits
+    String m_uuprotocol;                 // UserToUser protocol
+    String m_uuinformation;              // UserToUser information (up to 128 bytes)
 };
 
 /**
Index: yate/modules/server/ysigchan.cpp
===================================================================
--- yate.orig/modules/server/ysigchan.cpp	2016-01-15 12:40:57.000000000 +0300
+++ yate/modules/server/ysigchan.cpp	2016-01-15 12:44:28.000000000 +0300
@@ -1086,7 +1086,7 @@
     // call.preroute message
     m_route = message("call.preroute",false,true);
     // Parameters to be copied to call.preroute
-    static String params = "caller,called,callername,format,formats,callernumtype,callernumplan,callerpres,callerscreening,callednumtype,callednumplan,inn,overlapped";
+    static String params = "caller,called,callername,format,formats,callernumtype,callernumplan,callerpres,callerscreening,callednumtype,callednumplan,inn,overlapped,uuprotocol,uuinformation";
     plugin.copySigMsgParams(*m_route,event,&params);
 #if 0
     if (m_route->getBoolValue("overlapped") && !m_route->getValue("called"))
@@ -1241,6 +1241,8 @@
     sigMsg->params().copyParam(msg,"inn");
     sigMsg->params().copyParam(msg,"calledpointcode");
     sigMsg->params().copyParam(msg,"overlapped");
+    sigMsg->params().copyParam(msg,"uuprotocol");
+    sigMsg->params().copyParam(msg,"uuinformation");
     // Copy RTP parameters
     if (msg.getBoolValue("rtp_forward")) {
 	NamedList* tmp = new NamedList("rtp");
