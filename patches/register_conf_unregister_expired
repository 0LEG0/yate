Description: Allow register module to issue unregistration queries for expired registrations
Author: vir@ctm.ru
---
Enabled by 'unregister_expired' option in register.conf.
Index: yate/conf.d/register.conf.sample
===================================================================
--- yate.orig/conf.d/register.conf.sample	2016-01-15 13:37:28.000000000 +0300
+++ yate/conf.d/register.conf.sample	2016-01-15 14:46:26.000000000 +0300
@@ -4,6 +4,9 @@
 ; expires: int: Will execute the engine.timer query only every that many seconds
 ;expires=30
 
+; unregister_expired: bool: Dispatch user.unregister messages for every row, returned by expiration query
+;unregister_expired=no
+
 ; stoperror: regexp: Regular expression matching errors that will stop fallback
 ;stoperror=busy
 
@@ -97,9 +100,10 @@
 
 [engine.timer]
 ; Query for the timer message that expires registrations
-; Also look at the expires setting in section [general]
+; Also look at the 'expires' and 'unregister_expired' settings in section [general]
 
 ;query=UPDATE users SET location=NULL,expires=NULL WHERE expires IS NOT NULL AND expires<=CURRENT_TIMESTAMP
+;query=SELECT username, location AS data, 'true' AS expired FROM users WHERE expires IS NOT NULL AND expires<=CURRENT_TIMESTAMP;
 
 
 [call.preroute]
Index: yate/modules/server/register.cpp
===================================================================
--- yate.orig/modules/server/register.cpp	2016-01-15 13:37:28.000000000 +0300
+++ yate/modules/server/register.cpp	2016-01-15 14:46:26.000000000 +0300
@@ -28,6 +28,7 @@
 static bool s_critical = false;
 static u_int32_t s_nextTime = 0;
 static int s_expire = 30;
+static bool s_unregister_expired = false;
 static bool s_errOffline = true;
 static ObjList s_handlers;
 
@@ -435,6 +436,25 @@
     return false;
 }
 
+static void dispatchUserUnregisterForExpired(Array * a)
+{
+    if (!a)
+	return;
+    for (int j=1; j < a->getRows();j++) {
+	Message* m = new Message("user.unregister");
+	for (int i=0; i<a->getColumns();i++) {
+	    const String* name = YOBJECT(String,a->get(i,0));
+	    if (!(name && *name))
+		continue;
+	    const String* s = YOBJECT(String,a->get(i,j));
+	    if (!s)
+		continue;
+	    m->setParam(*name,*s);
+	}
+	Engine::enqueue(m);
+    }
+}
+
 bool AAAHandler::received(Message& msg)
 {
     if (m_query.null() || m_account.null())
@@ -546,10 +566,20 @@
 		s_nextTime = t + s_expire;
 	    else
 		return false;
-	    // no error check needed - we enqueue the query and return false
-	    Message* m = new Message("database");
-	    prepareQuery(*m,account,query,false);
-	    Engine::enqueue(m);
+	    if(s_unregister_expired) {
+		if(m_queryReturnsNameValuePairs)
+		    Debug(&module,DebugWarn,"Misconfigured: namevaluepairs in '%s' (ignored)",name().c_str());
+		Message m("database");
+		prepareQuery(m,account,query,true);
+		if (Engine::dispatch(m))
+		    if (m.getIntValue("rows") >=1)
+			dispatchUserUnregisterForExpired(static_cast<Array*>(m.userObject("Array")));
+	    } else {
+		// no error check needed - we enqueue the query and return false
+		Message* m = new Message("database");
+		prepareQuery(*m,account,query,false);
+		Engine::enqueue(m);
+	    }
 	}
 	break;
     }
@@ -1053,6 +1083,7 @@
     setup();
     Output("Initializing module Register for database");
     s_expire = s_cfg.getIntValue("general","expires",s_expire);
+    s_unregister_expired = s_cfg.getBoolValue("general","unregister_expired",false);
     s_errOffline = s_cfg.getBoolValue("call.route","offlineauto",true);
     Engine::install(new MessageRelay("engine.start",this,Private,150));
     addHandler("call.cdr",AAAHandler::Cdr);
